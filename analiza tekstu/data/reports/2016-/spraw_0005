przedmiot TAS temat A nr_indeksu 396377 liczba_pkt 6 

\n\n!!!!\ WA¯NA\ UWAGA\ !!!!\n\nZadania\ by³y\ robione\ na\ komputerach\ wydzia³owych\ oraz\ na\ moim\ w³asnym,\ st±d\ w\ wydrukach\ z\ wiersza\ poleceñ\ mo¿e\ pojawiæ\ siê\ znak\ zachêty\ `\ -lupus@aterum-:~\$\ `\ --\ pochodzi\ on\ z\ mojego\ komputera!\n\n***************\ ZADANIE\ A.1\ ****************\n\nW\ RPC\ trudno\ przekazywaæ\ struktury\ danych\ oparte\ na\ wska¼nikach.\ Wska¼nik\ ma\ znaczenie\ tylko\ w\ obrêbie\ procesu,\ w\ którym\ zosta³\ utworzony.\ Tablice\ o\ nieokre¶lonej\ d³ugo¶ci\ oraz\ same\ wska¼niki\ s±\ jednym\ z\ obszarów\ problemów\ w\ RPC.\n\nDlatego\ u¿ywa\ siê\ XDR,\ który\ pozwala\ na\ przes³anie\ danych\ niezale¿nie\ od\ komputera.\n\n###########\ KONIEC\ ZADANIA\ A.1\ #############\n\n\n***************\ ZADANIE\ 1\ ******************\nPo\ u¿yciu\ rpcgen\ na\ pliku:\n\n-----------------plik.x---------------------\nstruct\ Macierz\ \{\n\ \ float\ Elem\ <>\;\n\ \ int\ IleW\;\ int\ IleK\;\n\}\;\ntypedef\ struct\ Macierz\ Mac\;\n\nstruct\ TrzyMacierze\ \{\ Mac\ M1\;\ Mac\ M2\;\ Mac\ M3\;\ \}\;\ntypedef\ struct\ TrzyMacierze\ TrzyMac\;\n\nprogram\ ProgMacierze\ \{\n\ \ version\ VerMacierze\ \{\n\ \ \ \ void\ PokazMacierz(Mac)\ =\ 1\;\n\ \ \ \ void\ OperacjaNaMacierzach(TrzyMac)\ =\ 2\;\n\ \ \}\ =\ 1\;\n\}\ =\ 0x21001234\;\n--------------KONIEC\ PLIKU-------------------\n\nrpcgen\ t³umaczy\ strukturê\ Macierz\ na\ nastêpuj±cy\ kod:\n\n------------KOD\ ¬RÓD£OWY\ plik.h-----------\n(...)\nstruct\ Macierz\ \{\n\ \ \ \ \ \ \ \ struct\ \{\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ u_int\ Elem_len\;\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ float\ *Elem_val\;\n\ \ \ \ \ \ \ \ \}\ Elem\;\n\ \ \ \ \ \ \ \ int\ IleW\;\n\ \ \ \ \ \ \ \ int\ IleK\;\n\}\;\n(...)\n------------KONIEC\ FRAGMENTU--------------\n\nWidzimy\ tutaj,\ ¿e\ tablica\ o\ zmiennej\ ilo¶ci\ elementów\ jest\ t³umaczona\ na\ strukturê,\ w\ której\ znajduje\ siê\ liczba\ elementów\ u_int\ Elem_len\ oraz\ wska¼nik\ na\ typ\ float\ *Elem_val.\nZ\ powy¿szego\ wynika,\ ¿e\ samodzielnie\ musimy\ zaalokowaæ\ pamiêæ\ dla\ odpowiedniej\ d³ugo¶ci\ tablicy.\n\n############KONIEC\ ZADANIA\ 1##############\n\n\n***************\ ZADANIE\ 2\ ****************\nAby\ aplikacja\ dzia³a³a\ poprawnie,\ nale¿y\ wprowadziæ\ zmiany\ w\ plikach\ sum_client.c\ i\ sum_server.c.\ \nZmiany\ pokazane\ s±\ w\ za³±czonych\ plikach\ diff:\ sum_client.diff\ i\ sum_server.diff.\nOmówienie\ zmian\ w\ kliencie:\nNale¿y\ spowodowaæ,\ by\ program\ przyjmowa³\ wiêcej\ argumentów:\ host,\ x1\ i\ x2.\nNastêpnie\ nale¿y\ przekazaæ\ argumenty\ do\ funkcji\ progservice_1,\ w\ której\ tworzona\ jest\ odpowiednia\ struktura,\ wype³niona\ argumentami\ x1\ i\ x2.\nOmówienie\ zmian\ w\ serwerze:\nW\ serwerze\ jedynie\ nale¿y\ wstawiæ\ kod,\ który\ oblicza\ wynik\n\n\tresult\ =\ argp->x1\ +\ argp->x2\;\n\nWynik\ dzia³ania\ programu\ (serwer\ uruchomiony\ na\ localhost):\n\n#\ts396377@pc22b:\[~/rpc/zad2\]\$\ ./sum_client\ localhost\ 3\ 4\n#\t7\ \n#\ts396377@pc22b:\[~/rpc/zad2\]\$\ ./sum_client\ localhost\ 256\ -56\n#\t200\ \n\nrpcinfo\ -p\ w\ trakcie\ dzia³ania\ serwera:\n\n#\ts396377@pc22b:\[~/rpc/zad2\]\$\ rpcinfo\ -p\n#\t\ \ \ program\ vers\ proto\ \ \ port\ \ service\n#\t\ \ \ \ 100000\ \ \ \ 4\ \ \ tcp\ \ \ \ 111\ \ portmapper\n#\t\ \ \ \ 100000\ \ \ \ 3\ \ \ tcp\ \ \ \ 111\ \ portmapper\n#\t\ \ \ \ 100000\ \ \ \ 2\ \ \ tcp\ \ \ \ 111\ \ portmapper\n#\t\ \ \ \ 100000\ \ \ \ 4\ \ \ udp\ \ \ \ 111\ \ portmapper\n#\t\ \ \ \ 100000\ \ \ \ 3\ \ \ udp\ \ \ \ 111\ \ portmapper\n#\t\ \ \ \ 100000\ \ \ \ 2\ \ \ udp\ \ \ \ 111\ \ portmapper\n#\t\ \ \ \ 100024\ \ \ \ 1\ \ \ udp\ \ 52703\ \ status\n#\t\ \ \ \ 100024\ \ \ \ 1\ \ \ tcp\ \ 35892\ \ status\n#\t\ \ \ \ 100021\ \ \ \ 1\ \ \ udp\ \ 46322\ \ nlockmgr\n#\t\ \ \ \ 100021\ \ \ \ 3\ \ \ udp\ \ 46322\ \ nlockmgr\n#\t\ \ \ \ 100021\ \ \ \ 4\ \ \ udp\ \ 46322\ \ nlockmgr\n#\t\ \ \ \ 100021\ \ \ \ 1\ \ \ tcp\ \ 47255\ \ nlockmgr\n#\t\ \ \ \ 100021\ \ \ \ 3\ \ \ tcp\ \ 47255\ \ nlockmgr\n#\t\ \ \ \ 100021\ \ \ \ 4\ \ \ tcp\ \ 47255\ \ nlockmgr\n#\t\ 553652788\ \ \ \ 1\ \ \ udp\ \ 49049\n#\t\ 553652788\ \ \ \ 1\ \ \ tcp\ \ 46081\n#\t\ 553648128\ \ \ \ 1\ \ \ udp\ \ 47902\n#\t\ 553648128\ \ \ \ 1\ \ \ tcp\ \ 55037\n#\ts396377@pc22b:\[~/rpc/zad2\]\$\ \n\n\n############KONIEC\ ZADANIA\ 2##############\n\n\n************ZADANIE\ 3\ ********************\n\nNajpierw\ tworzymy\ macierz.x:\n\n----macierz.x-----\nstruct\ Macierz\ \{\n\tfloat\ Elem\ <>\;\n\tint\ IleW\;\ int\ IleK\;\n\}\;\ntypedef\ struct\ Macierz\ Mac\;\n\nprogram\ ProgMacierze\ \{\n\ version\ VerMacierze\ \{\n\tvoid\ WyslijMacierz(Mac)\ =\ 1\;\n\t\}\ =\ 1\;\n\}\ =\ 0x21001234\;\n-------------------\n\nwprowadzamy\ poprawki\ w\ kodzie:\ dodajemy\ funkcje\ wprowadzania\ macierzy\ o\ zadanym\ rozmiarze,\ zwalniania\ pamiêci\ etc.\n----\ macierz_client.diff\ ----\n\n---\ clean/macierz_client.c\t2015-10-14\ 11:10:55.510076500\ +0200\n+++\ macierz_client.c\t2015-10-14\ 11:05:24.894093600\ +0200\n@@\ -8,11\ +8,11\ @@\n\ \n\ \n\ void\n-progmacierze_1(char\ *host)\n+progmacierze_1(char\ *host,\ Mac\ *m)\n\ \{\n\ \tCLIENT\ *clnt\;\n\ \tvoid\ \ *result_1\;\n-\tMac\ \ wyslijmacierz_1_arg\;\n+\tMac\ \ wyslijmacierz_1_arg\ =\ *m\;\n\ \n\ #ifndef\tDEBUG\n\ \tclnt\ =\ clnt_create\ (host,\ ProgMacierze,\ VerMacierze,\ \"udp\")\;\n@@\ -25,13\ +25,41\ @@\n\ \tresult_1\ =\ wyslijmacierz_1(&wyslijmacierz_1_arg,\ clnt)\;\n\ \tif\ (result_1\ ==\ (void\ *)\ NULL)\ \{\n\ \t\tclnt_perror\ (clnt,\ \"call\ failed\")\;\n+\t\}\ else\ \{\n+\t\ \ printf(\"Send\ OK\\n\")\;\n\ \t\}\n\ #ifndef\tDEBUG\n\ \tclnt_destroy\ (clnt)\;\n\ #endif\t\ /*\ DEBUG\ */\n\ \}\n+void\ setElem(int\ i,\ int\ j,\ Mac\ *m,\ float\ val)\{\n+\tint\ k\ =\ m->IleK\;\n+\tint\ w\ =\ m->IleW\;\n+\tm->Elem.Elem_val\[k*i\ +\ j\]\ =\ val\;\n+\}\n\ \n-\n+void\ wprowadzMacierz(int\ k,\ int\ w,\ Mac\ *m)\ \{\n+\ \ float\ e\;\n+\ \ m->Elem.Elem_len\ =\ k*w\;\n+\ \ m->IleK\ =\ k\;\n+\ \ m->IleW\ =\ w\;\n+\ \ m->Elem.Elem_val\ =\ calloc(k*w,\ sizeof(float))\;\n+\ \ int\ i=0\;\n+\ \ int\ j=0\;\n+\ \ for(i=0\;\ i<w\;\ i++)\ \{\n+\ \ \ \ printf(\"Wiersz\ numer\ %d\\n\",\ i)\;\n+\ \ \ \ for\ (j=0\;\ j<k\;\ j++)\ \{\n+\n+\ \ \ \ \ \ scanf(\"%f\",\ &e)\;\n+\ \ \ \ \ \ setElem(i,\ j,\ m,\ e)\;\n+\ \ \ \ \ \ \}\n+\ \ \}\n+\}\n+void\ freeMacierz(Mac\ *m)\ \{\n+\ \ printf(\"Freeing\ memory...\\n\")\;\n+\ \ free(m->Elem.Elem_val)\;\n+\ \ printf(\"Memory\ freed.\\n\")\;\n+\}\n\ int\n\ main\ (int\ argc,\ char\ *argv\[\])\n\ \{\n@@\ -41,7\ +69,14\ @@\n\ \t\tprintf\ (\"usage:\ %s\ server_host\\n\",\ argv\[0\])\;\n\ \t\texit\ (1)\;\n\ \t\}\n+\tprintf(\"Podaj\ liczbe\ wierszy\ i\ kolumny\\n\")\;\n+\tint\ k,\ w\;\n+\tscanf(\"%d\",\ &w)\;\n+\tscanf(\"%d\",\ &k)\;\n+\tMac\ m\;\n+\twprowadzMacierz(k,\ w,\ &m)\;\n\ \thost\ =\ argv\[1\]\;\n-\tprogmacierze_1\ (host)\;\n-exit\ (0)\;\n+\tprogmacierze_1\ (host,\ &m)\;\n+\tfreeMacierz(&m)\;\n+\texit\ (0)\;\n\ \}\n\n-----\ koniec\ pliku\ .diff\ ----\n\nW\ kodzie\ serwera\ umieszczamy\ instrukcje\ wy¶wietlania\ otrzymanej\ macierzy:\n\n----\ macierz_serwer.diff\ ----\n\n---\ clean/macierz_server.c\t2015-10-14\ 11:10:55.502076100\ +0200\n+++\ macierz_server.c\t2015-10-14\ 11:13:16.332886200\ +0200\n@@\ -5,15\ +5,25\ @@\n\ \ */\n\ \n\ #include\ \"macierz.h\"\n-\n+#include\ <stdlib.h>\n\ void\ *\n\ wyslijmacierz_1_svc(Mac\ *argp,\ struct\ svc_req\ *rqstp)\n\ \{\n\ \tstatic\ char\ *\ result\;\n\ \n-\t/*\n-\t\ *\ insert\ server\ code\ here\n-\t\ */\n+\tMac\ *m\ =\ argp\;\n+\tint\ k\ =\ m->IleK\;\n+\tint\ w\ =\ m->IleW\;\n+\tint\ i=0\;\n+\tint\ j=0\;\n+\tfor(i=0\;\ i<w\;\ i++)\ \{\n+\t\ \ for\ (j=0\;\ j<k\;\ j++)\ \{\n+\t\ \ \ \ printf(\"%f\",\ m->Elem.Elem_val\[i*k\ +\ j\])\;\n+\t\ \ \ \ printf(\"\ \")\;\n+\t\ \ \}\n+\tprintf(\"\\n\")\;\n+\t\}\n+\n\ \n\ \treturn\ (void\ *)\ &result\;\n\ \}\n\n\n-----\ koniec\ pliku\ .diff\ ---\n\nProgram\ klienta\ poprawnie\ zwalnia\ pamiêæ\ po\ wys³aniu\ macierzy.\n\n-lupus@aterum-:~/rpc/zad3\$\ ./macierz_client\ localhost\nPodaj\ liczbe\ wierszy\ i\ kolumny\n2\n3\nWiersz\ numer\ 0\n1\n1\n1\nWiersz\ numer\ 1\n2\n2\n2\nSend\ OK\nFreeing\ memory...\nMemory\ freed.\n-lupus@aterum-:~/rpc/zad3\$\n\nstrona\ serwera:\n-lupus@aterum-:~/rpc/zad3\$\ ./macierz_server\ \n1.000000\ 1.000000\ 1.000000\ \n2.000000\ 2.000000\ 2.000000\ \n<...\ dzia³a\ dalej\ w\ tle\ >\n\n########\ KONIEC\ ZADANIA\ 3\ ###################\n\n\n\n*****************\ ZADANIE\ 4\ ****************\n\nplik\ \"opMac.x\"\ wygl±da\ nastêpuj±co\ (bazowany\ na\ zadaniu\ nr\ 3):\n\n-------\ opMac.x\ --------\nstruct\ Macierz\ \{\n\ \ \ \ \ \ \ float\ Elem\ <>\;\n\ \ \ \ \ \ \ int\ wie\;\ int\ kol\;\n\ \ \ \ \ \ \ \}\;\ntypedef\ struct\ Macierz\ Mac\;\nstruct\ DwieMacierze\ \{\ Mac\ M1\;\ Mac\ M2\;\ \}\;\ntypedef\ DwieMacierze\ DwieMac\;\nprogram\ OperacjeNaMacierzach\ \{\n\tversion\ VerMacierze\ \{\n\t\t\ Mac\ dodaj(DwieMac)\ =\ 1\;\n\t\t\ Mac\ pomnoz(DwieMac)\ =\ 2\;\n\t\t\ \}\ =\ 1\;\n\t\ \}\ =\ 0x21001234\;\n-------\ koniec\ pliku\ opMac.x\ ----\n\nWidzimy\ tutaj\ dodatkow±\ strukturê\ DwieMacierze.\ Jest\ to\ zrobione\ w\ ten\ sposób,\ poniewa¿\ mo¿na\ przes³aæ\ tylko\ jeden\ argument.\nOperacje\ dodawania\ i\ mno¿enia\ s±\ zdefiniowane\ jako\ osobne\ procedury.\ W\ kliencie\ odbywa\ siê\ przetwarzanie\ wyboru\ procedury,\ któr±\ chce\ wykonaæ\ u¿ytkownik.\n\n\nZmiany\ w\ kodzie\ w\ stosunku\ do\ zadania\ 3?\n\nNale¿a³o\ dodaæ\ procedury\ wprowadzania\ macierzy,\ ³±czenia\ ich\ w\ jedn±\ oraz\ poprawiæ\ procedury.\nZe\ wzglêdu\ na\ swoj±\ wielko¶æ\ pliki\ diff\ (opMac_client.c.diff,\ opMac_server.c.diff)\ s±\ dodane\ jako\ za³±cznik\ (ró¿nica\ wzglêdem\ wygenerowanych\ plików\ a\ plikami\ poprawionymi\ przeze\ mnie).\nMy¶lê,\ ¿e\ one\ najlepiej\ oddaj±\ to,\ co\ zosta³o\ zmienione\ w\ kodzie!\n\nWa¿na\ uwaga:\ je¶li\ oka¿e\ siê,\ ¿e\ wprowadzonych\ macierzy\ nie\ mo¿na\ dodaæ/pomno¿yæ,\ serwer\ zwróci\ NULL,\ co\ spowoduje\ \"call\ failed\".\n\n###############\ KONIEC\ ZADANIA\ 4\ #############\n\n\n*************\ ZADANIE\ 5\ *****************\n\nWykorzystujemy\ tu\ plik\ sum.x\ z\ zadania\ numer\ 2\ oraz\ kod\ ¼ród³owy\ z\ zadania\ nr\ 2\ (z\ niewielkimi\ poprawkami\ --\ dodane\ sleep(5)\ w\ procedurze\ serwera\ przed\ return,\ oraz\ ustawianie\ timeout\ w\ kliencie).\n\n\n\nParametry\ TIMEOUT\ i\ TIMEOUT_RETRY\ kontroluj±\ czas,\ po\ którym\ wyst±pi\ b³±d\ 'timeout'\ oraz\ czas,\ po\ którym\ ¿±danie\ bêdzie\ retransmitowane.\n\nAby\ klient\ doczeka³\ siê\ odpowiedzi,\ gdy\ w\ funkcji\ zdalnej\ jest\ sleep(5),\nTIMEOUT\ i\ TIMEOUT_RETRY\ musz±\ byæ\ >5\ sekund.\n\nparmetry\ te\ ustawia\ siê:\n\n(...\ wcze¶niej\ musi\ byæ\ clnt_create)\nstruct\ timeval\ tv\;\ntv.tv_sec\ =\ 5\;\ //\ czas\ w\ sekundach\ntv.tv_usec\ =\ 0\;\ //\ czas\ w\ ms\nclnt_control(clnt,\ CLSET_TIMEOUT,\ &tv)\;\nclnt_control(clnt,\ CLSET_RETRY_TIMEOUT,\ &tv)\;\n(...)\n\nGdy\ klient\ nie\ doczeka\ siê\ odpowiedzi,\ zwróci\ b³±d\ \"timeout\".\n\n############\ KONIEC\ ZADANIA\ 5\ #####################3\n\n
