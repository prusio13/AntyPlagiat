przedmiot TAS temat A nr_indeksu 384283 liczba_pkt 6 




ZADANIE 1 -------------------------------------
Zbadaj i opisz jak rpcgen tlumaczy bardziej z³o¿one struktury danych,
ktorych def jest podana poni¿ej;
aby wykonaæ to zadanie skompiluj plik "rpcgen -aC plik.x"
a potem zajrzyj do plikow ...

Aby t³umaczyæ bardziej z³o¿one struktury danych konieczne jest podanie wska¼nika
do tablicy i jej d³ugo¶ci.

ZADANIE 2 -------------------------------------
Zaprogramuj aplikacje "sum.x" i wyprobuj jej dzialanie;
w aplikacji tej klient uruchamia proc RPC, która sumuje dwie liczby;
te dwie liczby powinny byæ parametrami wywo³ania klienta;
klient powinien wypisywaæ tak¿e wynik dodawania;
zmiany jakie trzeba wprowadziæ do sum_client.c i sum_server.c ³atwo zauwa¿yæ
gdy siê do tych plików zajrzy...
klienta i serwer uruchamiaj na lokalnej maszynie;
zobacz jakie proc RPC s± dostêpne przy pomocy "rpcinfo -p";
do sprawozdania wstaw odpowiednie wydruki!

W kodzie wprowadzi³am nastêpuj±ce zmiany:

-------------------------------sum_server.c------------------------------------- 

/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "sum.h"

int *
suma_1_svc(ParaLi *argp, struct svc_req *rqstp)
{
	static int  result;

	/*
	 * insert server code here
	 */
        printf("%d %d\n", argp->x1, argp->x2); 
        result = argp->x1 + argp->x2;
    return &result;
}


------------------------------sum_client.c-------------------------------------- 

#include "sum.h"


void
progservice_1(char *host, int x1, int x2)
{
	CLIENT *clnt;
	int  *result_1;
	ParaLi  add2arg;

#ifndef	DEBUG
	clnt = clnt_create (host, PROGSERVICE, VERSERVICE, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

        add2arg.x1 = x1;
        add2arg.x2 = x2;

	result_1 = suma_1(&add2arg,clnt);
	if (result_1 == (int *) NULL) {
		clnt_perror (clnt,"call failed");
	}
        printf("Szukana suma:%d\n",*result_1);

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


int
main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	progservice_1 (host, atoi( argv[2]) ,atoi( argv[3] ));
exit (0);
}

----------------------------wydruk z konsoli:----------------------------------

KLIENT:
s384283@pc25i:~/Desktop/TAS/sum_client 127.0.0.1 10 12
Szukana suma: 22
s384283@pc25i:~/Desktop/TAS/sum_client 127.0.0.1 1 7
Szukana suma: 8

SERWER:

s384283@pc25i:~/Desktop/TAS/SUM$ ./sum_server
10 12
1 7

ZADANIE 3 -------------------------------------
Zdefiniuj proc RPC pozwalaj±c± przes³aæ macierz o dowolnych wymiarach do serwera
oraz wy¶wietliæ j± na terminalu po stronie serwera;
koniecznie pamiêtaj o mo¿liwych wyciekach pamiêci!! 
pliki:

---------------------------przesmacierzy_client.c-------------------------------

void
progservice_1(char *host)
{
	CLIENT  *clnt;
	int   *result_1;
	macierz writeFirst;

#ifndef	DEBUG
	clnt=clnt_create (host, PROGSERVICE, VERSERVICE, "udp");
	if (clnt==NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

    int rows,colums;
		
	printf("Podaj liczbe wierszy i kolumn\n");
    scanf("%d%d",&rows,&columns);

	write_arg.x.x_val = calloc(rows * columns, sizeof(int));
	write_arg.x.x_len = rows * columns;
	write_arg.columns = columns;
        write_arg.rows = rows;

	int i1, i2;	
	for (i1 = 0 ; i1 < rows * columns; i1++ ) {
		scanf( "%d", write_arg.x.x_val + i1  );
	}

	result_1=write(&write_arg, clnt);
	if (result_1==(int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	free(write_arg.x.x_val);
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif
}

---------------------------przesmacierzy_server.c-------------------------------

wypiszFunc(macierz *argp, struct svc_req *rqstp)
{
	static int result;

	int i;
	for(i = 0; i <argp->columns * argp->rows; ++i) {
		printf("%d ", argp->x.x_val[i] );
		if(i % argp->columns == argp->columns - 1 ) {
            printf( "\n" );
        }
	}
	return &result;
}

-----------------------------wydruk z konsoli-----------------------------------
 
s384283@pc25i:~/Desktop/TAS/przesmacierzy_client localhost
4 4
1 2 3 4
5 6 7 8
9 1 2 3
4 5 6 7 	

s384283@pc25i:~/Desktop/TAS/przesmacierzy_server
1 2 3 4
5 6 7 8
9 1 2 3
4 5 6 7


ZADANIE 4 -------------------------------------
Zdefiniuj proc RPC pozwalaj±ce wykonywaæ operacje na macierzach (mno¿enie i dodawanie);
zwróæ uwagê, ¿e teraz macierze bêd± przekazywane w obie strony: kli->ser i ser->kli;
zadbaj o prawid³owe zwalnianie pamiêci (patrz te¿ uwagi poni¿ej na ten temat!);
do sprawozdania wstaw wydruki i kluczowe fragmenty kodu (zwlaszcza plik.x)


------------------------------------client--------------------------------------

DODAWANIE

#include "macierz.h"
void
progservice_1(char *host)
{
	CLIENT  *clnt;
	matrix   *result_1;
	matrix2   addarg;

	int rows,columns;
		
	scanf("%d%d", &rows, &columns);

	addarg.a.x.x_val = calloc(rows*columns, sizeof(int));
	addarg.b.x.x_val = calloc(rows*columns, sizeof(int));
        addarg.a.x.x_len=rows*columns;
        addarg.b.x.x_len=rows*columns;
	    addarg.a.r=rows;
        addarg.a.k=columns;
        addarg.b.r=rows;
        addarg.b.k=columns;
	for (int i=0; i<rows*columns; i++) {
		scanf("%d", addarg.a.x.x_val + i);
    }

	for (int i=0; i<rows*columns; i++) {
        scanf("%d", addarg.b.x.x_val + i);
    }

#ifndef	DEBUG
	clnt=clnt_create (host, PROGSERVICE, VERSERVICE, "udp");
	if (clnt==NULL) {
		clnt_pcreateerror(host);
		exit (1);
	}
#endif

	result_1 = add_1(&addarg, clnt);
	if (result_1 == (matrix *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	
	for (i=0; i<result_1->r*result_1->k;++i ) {
		printf("%d ", result_1->x.x_val[i]);
		if (i % result_1->r == result_1->r - 1) {
            printf("\n");
        }
	}

#ifndef	DEBUG
	clnt_destroy (clnt);
	xdr_free ((xdrproc_t) xdr_matrix, (char *) result_1);

#endif
}

MNO¯ENIE

void
progservice_2(char *host)
{
	CLIENT*clnt;
	matrix *result_1;
	matrix2 addarg;

	int rows, columns, rows1, columns1;
		
	scanf("%d%d",&rows,&columns);
    addarg.a.x.x_val=calloc(rows*columns,sizeof(int));

	for(int i=0; i<rows * columns; i++) {
		scanf( "%d",addarg.a.x.x_val+i );
    }
	scanf("%d%d",&rows1,&columns1);
	addarg.b.x.x_val=calloc(rows1,columns1,sizeof(int));

        addarg.a.x.x_len=rows*columns;
        addarg.b.x.x_len=rows1*columns1;

	    addarg.a.r=rows;
        addarg.a.k=columns;

        addarg.b.r=rows1;
        addarg.b.k=columns1;


	for(int i=0; i<rows1*columns1; i++) {
                scanf("%d",addarg.b.x.x_val + i);
        }
 

#ifndef	DEBUG
	clnt = clnt_create (host, PROGSERVICE, VERSERVICE, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif
	result_1 = times_1(&addarg, clnt);
	if (result_1 == (matrix *) NULL) {
		clnt_perror (clnt, "call failed");
	}


	for(int i = 0; i < result_1->r * result_1->k; ++i)
	{
		printf("%d ", result_1->x.x_val[i]);
		if( i % result_1->r == result_1->r - 1 ) {
            printf("\n");
        }
	}

	xdr_free ((xdrproc_t) xdr_matrix, (char *) result_1);
	free(addarg.a.x.x_val);
	free(addarg.b.x.x_val);

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif
}

int
main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	progservice_2 (host);
exit (0);
}


------------------------------------serwer--------------------------------------

DODAWANIE

#include "macierz.h"
matrix *
add_1_svc(matrix2 *argp, struct svc_req *rqstp)
{
static matrix result;

	matrix* A=&argp->a;
	matrix* B=&argp->b;
	
	if((A->r!= B->r)|| (A->k!= B->k)){
		printf("Zly rozmiar macierzy");
		return NULL;
	}
	result.r=A->r;
	result.k=A->k;
	result.x.x_val = calloc( A->k * A->r, sizeof(int));
	result.x.x_len = A->k * A->r;

	for(int i=0; i<A->k*A->r; i++) {
		result.x.x_val[i]=A->x.x_val[i]+B->x.x_val[i];
	}
	return &result;
}

MNO¯ENIE

matrix*
times_1_svc(matrix2 *argp, struct svc_req *rqstp)
{
	static matrix result;
	macierz* A = &argp->a;
	macierz* B = &argp->b;
	
	if((A->k!= B->r){
		printf("Zly rozmiar macierzy");
		return NULL;
	}

	result.r=A->r;
	result.k=B->k;
	result.x.x_val=calloc(result.k * result.r,sizeof(int));
	result.x.x_len=result.k * result.r;

	for(int i=0; i<result.r; i++){
		for(int j=0; j<result.k; j++){
			for(int k=0; k<A->k; k++){
				result.x.x_val[i*result.k+j]+=A->x.x_val[i*A->k+k]*B->x.x_val[k*B->k+j];				
			}	
		}
	}
	return &result;
}

-----------------------------wydruk z konsoli-----------------------------------

DODAWANIE

s384283@pc25i:~/Desktop/TAS/ ./macierz_client localhost
3 3

1 1 1
2 2 2
3 3 3

1 1 1
1 1 1
1 1 1

2 2 2
3 3 3
4 4 4
s384283@pc25i:~/Desktop/TAS/ ./macierz_server

MNO¯ENIE

s384283@pc25i:~/Desktop/TAS/ ./macierz_client localhost
2 3
1 1 1
1 1 1

3 2
3 4
4 3
3 4

10 11
10 11

s384283@pc25i:~/Desktop/TAS/ ./macierz_server

ZADANIE 5 -------------------------------------
Zbadaj znaczenie parametrów TIMEOUT i TIMEOUT_RETRY po stronie klienta;
Aby eksperymentowaæ z tymi parametrami upewnij siê ¿e w pliku sum_client.c,
w funkcji clnt_create(), jest ustawiony transport "udp" (tylko wtedy te parametry maja znaczenie);
nastêpnie modyfikuj te parametry przy pomocy funkcji clnt_control() - jej opis znajdziesz w manualu!
w procedurze sum_server dodaj do proc obliczaj±cej sume sleep(5);
jak sie teraz bêdzie teraz zachowywaæ klient??
jaka musi byæ warto¶æ TIMEOUT i TIMEOUT_RETRY aby klient doczeka³ siê wyniku?
ile razy jest wywo³ywana zdalna procedura?


Znaczenie parametrów:

Czas ponowienia zapytania do serwera - TIMEOUT_RETRY
Ile czasu nale¿y czekaæ na opodwied¼ serwera - TIMEOUT

Klient otrzymuje odpowied¼, je¿eli czas wykonywania danej procedury nie
przekroczy warto¶ci parametru TIMEOUT.

--------------------------------------------------------------------------------
int *
suma_1_svc(ParaLi *argp, struct svc_req *rqstp){
	static int result;

        printf("%d %d\n",argp->x1,argp->x2); 
        result=argp->x1+argp->x2;
	sleep(1);
	return &result;
}

void
progservice_1(char *host, int x1, int x2){
	CLIENT *clnt;
	int  *result_1;
	ParaLi add2arg;

#ifndef	DEBUG
	clnt = clnt_create (host, PROGSERVICE, VERSERVICE, "udp");
	if (clnt == NULL){
		clnt_pcreateerror (host);
		exit (1);
	}

	struct timeval TIMEOUT = {0,500000};
	clnt_control( clnt, CLSET_TIMEOUT, &TIMEOUT );
	struct timeval TIMEOUT_RETRY = { 0, 0 };
	clnt_control( clnt, CLSET_RETRY_TIMEOUT, &TIMEOUT_RETRY );
#endif
        add2arg.x1 = x1;
        add2arg.x2 = x2;
	result_1 = suma_1(&add2arg, clnt);
	if (result_1 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}
        printf("Szukana suma:%d\n" ,*result_1);

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif
}

-----------------------------wydruk z konsoli-----------------------------------

timeout = 2s
timeout retry = 0.25s

serwer dostanie 4 zapytania, klient dostanie wynik

timeout = 0.5s
timeout retry = 0.25ss

serwer dostanie 2 zapytania, klient nie dostanie wyniku
(b³±d: 'call failed: RPC: Timed out')


------------------------------------serwer--------------------------------------
s384283@pc25i:~/Desktop/TAS sudo ./sum_server 
3 4

------------------------------------client--------------------------------------
s384283@pc25i:~/Desktop/TAS sudo ./sum_client localhost 3 4
Szukana suma: 7

TIMEOUT 1s TIMEOUT_RETRY 1s
------------------------------------serwer--------------------------------------
s384283@pc25i:~/Desktop/TAS sudo ./sum_server 
8 100

------------------------------------client--------------------------------------
TIMEOUT 0.5s, TIMEOUT_RETRY 0s:

s384283@pc25i:~/Desktop/TAS ./sum_client localhost 8 100
Szukana suma: 108

------------------------------------serwer--------------------------------------
s384283@pc25i:~/Desktop/TAS sudo ./sum_server  
8 100
8 100
8 100
8 100
8 100
8 100
...

ZADANIE 7 -------------------------------------
Spróbuj wywo³ywaæ procedury SUN/ONC RPC z poziomu jêzyka Java;
u¿yj oprogramowania "remotetea" http://remotetea.sourceforge.net/
(Uwaga: w tym zadaniu klient ma byæ javowy, serwer pozostaje napisany w j. C !!!) 

------------------------------------client--------------------------------------

import org.acplt.oncrpc.*;
import java.net.InetAddress;
import java.io.IOException;

public class get_sum {

	static int opt;
    public static void main(String [] args) {

    sumClient client = null;
	
	 try {
            client = new sumClient(InetAddress.getByName(args[0]),
                                    OncRpcProtocols.ONCRPC_TCP);
        } catch (Exception e) {
            System.out.println("infoline: error when creating RPC client:");
            e.printStackTrace(System.out);
        }

        client.getClient().setTimeout(200*1000);
        System.out.print("Making request to server");

	// make request object
	ParaLi arg1 =new ParaLi ();
	arg1.value.x1=Integer.parseInt(args[1]);
	arg1.value.x2=Integer.parseInt(args[2]);
      try {
            int res =client.suma_1(arg1);
            System.out.println("Result is:"+ (char)res);
        } catch (Exception e) {
		System.out.println("Error contacting server");
            e.printStackTrace(System.out);
            return;
        }
        try {
            client.close();
        } catch (Exception e) {
            System.out.println("infoline: error when closing client:");
            e.printStackTrace(System.out);
        }
        client = null;
    }
}

-----------------------------wydruk z konsoli-----------------------------------
s384283@pc25i:~/Desktop/TAS java -classpath oncrpc.jar get_sum localhost 2 17

Szukana suma: 19

s384283@pc25i:~/Desktop/TAS/JAVA$ sudo ./sum_server 

2 17

--------------------------------wniosek-----------------------------------------
Za pomoc± RPC mo¿na ³±czyæ ze sob± ró¿ne jêzyki programowania.
}
