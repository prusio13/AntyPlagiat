przedmiot TAS temat A nr_indeksu s396337 liczba_pkt 4 

\n\n\nZadanie\ 1\ --------------------------------------------------\t\n\nW\ pliku\ plik.x\ struktura\ struct\ Macierz\ wygl±da³a\ tak:\n\nstruct\ Macierz\ \{\n\ \ float\ Elem\ <>\;\n\ \ int\ IleW\;\ int\ IleK\;\n\}\;\n\nnatomiast\ w\ pliku\ plik.h\ wygl±da\ to\ nastêpuj±co:\n\nstruct\ Macierz\ \{\n\tstruct\ \{\n\t\tu_int\ Elem_len\;\n\t\tfloat\ *Elem_val\;\n\t\}\ Elem\;\n\tint\ IleW\;\n\tint\ IleK\;\n\}\;\nwidzimy\ wiêc\ jasno,\ w\ jaki\ sposób\ t³umaczone\ s±\ tablice\ przez\ rpcgen.\ \n\nZadanie\ 2\ -------------------------------------------------\n\nW\ pierwszej\ kolejno¶ci\ opiszê\ zmiany,\ które\ nale¿a³o\ wprowadziæ\ w\ pliku\ sum_client.c:\n\n-\ w\ metodzie\ progservice_1()\nvoid\nprogservice_1(char\ *host,int\ x,\ int\ y)\n\{\n\tCLIENT\ *clnt\;\n\tint\ \ *result_1\;\n\tParaLi\ \ suma_1_arg\;\t\n\n\tsuma_1_arg.x1=x\;\n\ \ \ \ suma_1_arg.x2=y\;\n\tprintf(\"%d\\n\",*result_1)\;\n\nnale¿a³o\ dodaæ\ przy\ wywo³aniu\ metody\ dwie\ zmienne\ liczbowe,\ które\ zostan±\ do\ siebie\ dodane,\ przypisaæ\ ich\ warto¶ci\ i\ na\ koñcu\ w\ celu\ wy¶wietlenia\ wyniku\ dodaæ\ standardowe\ wyj¶cie\ wy¶wietlaj±ce\ warto¶æ\ zmiennej\ result_1.\n\n-\ w\ main()\nint\nmain\ (int\ argc,\ char\ *argv\[\])\n\{\n\tchar\ *host\;\n\n\tif\ (argc\ <\ 2)\ \{\n\t\tprintf\ (\"usage:\ %s\ server_host\\n\",\ argv\[0\])\;\n\t\texit\ (1)\;\n\t\}\n\thost\ =\ argv\[1\]\;\n\tint\ arg_1\ =\ atoi(argv\[2\])\;\t\n\tint\ arg_2\ =\ atoi(argv\[3\])\;\t\n\n\tprogservice_1\ (host,\ arg_1,\ arg_2)\;\nexit\ (0)\;\n\}\n\nTutaj\ konieczne\ by³o\ po\ pierwsze\ dodanie\ dwóch\ pobieranych\ argumentów\ do\ wywo³ania\ metody\ progservice_1.\ Drug±\ rzecz±,\ o\ której\ nie\ mia³em\ pojêcia,\ gdy¿\ nie\ programujê\ czêsto\ w\ jêzyku\ C,\ by³a\ zmiana\ typu\ zmiennych\ standardowego\ wej¶cia.\ Dziêki\ koledze,\ który\ podpowiedzia³\ mi,\ mo¿na\ by³o\ to\ zrobiæ\ funkcj±\ atoi(),\ zmienia\ ona\ typu\ char\ na\ int.\n\nNastêpne\ zmiany\ musia³em\ dokonaæ\ w\ pliku\ sum_server.c:\n\nint\ *\nsuma_1_svc(ParaLi\ *argp,\ struct\ svc_req\ *rqstp)\n\{\n\tstatic\ int\ \ result\;\n\tresult=argp->x1+argp->x2\;\n\treturn\ &result\;\n\}\ntutaj\ wystarczy³o\ przypisanie\ argumentów\ oraz\ wykonanie\ dzia³ania,\ które\ zawiera\ zmienna\ result,\ nastêpnie\ zwrócenie\ go.\n\nNastêpnie\ program\ zosta³\ sprawdzony\ przez\ polecenie\ make\ -f\ Makefile.sum\ i\ wywo³anie\ go,\ w\ jednym\ oknie\ terminala\ klient,\ w\ drugim\ serwer.\n\nWydruk:\nTutaj\ ciê¿ko\ mi\ zrobiæ\ wydruk,\ gdy¿\ na\ komputerze\ uczelnianym\ nie\ mam\ praw,\ aby\ to\ zrobiæ.\n\n\n\nZadanie\ 3\ ----------------------------------------------------\n\nZmiany\ nale¿a³o\ wprowadziæ\ do\ plików\ matrix_client.c\ oraz\ matrix_server.c.\nPlik\ matrix.x\ wygl±da³\ nastêpuj±co:\n\nstruct\ Macierz\ \{\n\ \ float\ Elem\ <>\;\n\ \ int\ IleW\;\ int\ IleK\;\n\}\;\ntypedef\ struct\ Macierz\ Mac\;\n\nprogram\ ProgMacierze\ \{\n\ \ version\ VerMacierze\ \{\n\ \ \ \ void\ PokazMacierz(Mac)\ =\ 1\;\n\ \ \}\ =\ 1\;\n\}\ =\ 0x21001234\;\n\nZmiany\ w\ matrix_client.c:\n\n-\ w\ metodzie\ progmacierze_1\ nale¿a³o\ wczytaæ\ warto¶ci\ zmiennych\ IleW\ oraz\ ileK(odpowiednio\ ilo¶æ\ wierszy\ i\ kolumn),\ nastêpnie\ wymna¿aj±c\ przez\ siebie\ te\ warto¶ci\ obliczyæ\ warto¶æ\ \"d³ugo¶ci\"\ macierzy,\ czyli\ liczby\ elementów\ w\ niej.\ Pó¼niej\ u¿ywaj±c\ funkcji\ calloc()\ lokujemy\ pamiêæ\ i\ przypisujemy\ to\ do\ warto¶ci\ w\ macierzy.\ Nastêpniej\ w\ pêtli\ czytamy\ warto¶ci\ kolejnych\ elementów\ macierzy\ i\ na\ sam\ koniec\ zwalniamy\ pamiêæ.\n\nvoid\nprogmacierze_1(char\ *host)\n\{\n\tfloat\ x\ =\ 0\;\n\tCLIENT\ *clnt\;\n\tvoid\ \ *result_1\;\n\tMac\ \ pokazmacierz_1_arg\;\n\n\t\n\tprintf(\"Rows:\ \\n\")\;\n\tscanf(\"%i\",\ &pokazmacierz_1_arg.IleW)\;\n\tprintf(\"Columns:\ \\n\")\;\n\tscanf(\"%i\",\ &pokazmacierz_1_arg.IleK)\;\n\t\n\tpokazmacierz_1_arg.Elem.Elem_len\ =\ pokazmacierz_1_arg.IleW\ *\ pokazmacierz_1_arg.IleK\;\n\tpokazmacierz_1_arg.Elem.Elem_val\ =\ calloc(pokazmacierz_1_arg.Elem.Elem_len,\ sizeof(float))\;\n\n\tint\ i\;\n\tfor\ (i\ =\ 0\;\ i\ <\ pokazmacierz_1_arg.Elem.Elem_len\;\ i++)\ \{\n\t\tprintf(\"Enter\ the\ value:\ %i\\n\",\ i)\;\n\t\tscanf(\"%f\",\ &x)\;\n\t\tpokazmacierz_1_arg.Elem.Elem_val\[i\]\ =\ x\;\n\t\}\n\tfree(pokazmacierz_1_arg.Elem.Elem_val)\;\n\nKolejnym\ zmieniamy\ plikiem\ by³\ plik\ matrix_server.c,\ a\ w\ nim\ wypisywanie\ za\ pomoc±\ pêtli\ elementów\ macierzy\ po\ stronie\ serwera.\n\nvoid\ *\npokazmacierz_1_svc(Mac\ *argp,\ struct\ svc_req\ *rqstp)\n\{\n\tstatic\ char\ *\ result\;\n\t\n\tint\ i\;\n\tfor\ (i\ =\ 0\;\ i\ <\ argp->IleW\ *\ argp->IleK\;\ i++)\ \{\n\t\tprintf(\"Element\[%i\]\ has\ value\ %f\\n\",\ i,\ argp->Elem.Elem_val\[i\])\;\n\t\}\n\n\treturn\ (void\ *)\ &result\;\n\}\n\nWydruk:\nSerwer:\ns396337@lts:~/Desktop/TAS\ sprawozdania/Temat\ A/zadanie\ 3\$\ ./matrix_server\nElement\[0\]\ has\ value\ 1.000000\nElement\[1\]\ has\ value\ 2.000000\nElement\[2\]\ has\ value\ 3.000000\nElement\[3\]\ has\ value\ 4.000000\n\nKlient:\ns396337@lts:~/Desktop/TAS\ sprawozdania/Temat\ A/zadanie\ 3\$\ ./matrix_client\ 127.0.0.1\nRows:\ \n2\nColumns:\ \n2\nEnter\ the\ value:\ 0\n1\nEnter\ the\ value:\ 1\n2\nEnter\ the\ value:\ 2\n3\nEnter\ the\ value:\ 3\n4\n\n\n\nZadanie\ 4\ --------------------------------------------------------\n\nPlik\ matrix.x\nstruct\ Macierz\ \{\n\ \ float\ Elem\ <>\;\n\ \ int\ IleW\;\ int\ IleK\;\n\}\;\ntypedef\ struct\ Macierz\ Mac\;\n\nstruct\ DwieMacierze\ \{\ Mac\ M1\;\ Mac\ M2\;\}\;\n\ntypedef\ struct\ DwieMacierze\ DwieMac\;\n\nprogram\ ProgMacierze\ \{\n\ \ version\ VerMacierze\ \{\n\ \ \ \ Mac\ dodaj(DwieMac)\ =\ 1\;\n\ \ \}\ =\ 1\;\n\}\ =\ 0x21001234\;\n\n\nZmiany\ równie¿,\ jak\ w\ poprzednich\ zadaniach,\ nale¿a³o\ wprowadziæ\ w\ plikach\ matrix_client.c\ oraz\ matrix_server.c.\ \n\nW\ matrix_client.c\ metoda\ progmacierze_1\ wygl±da\ bardzo\ podobnie\ do\ tej\ z\ zadania\ 3,\ z\ tym\ ¿e\ warto¶ci\ macierzy\ czytamy\ dwa\ razy(odpowiednio\ dla\ pierwszej,\ a\ nastêpnie\ dla\ drugiej).\ Liczba\ kolumn\ i\ wierszy\ jest\ ustalana\ tylko\ raz(warunek,\ ¿e\ musz±\ byæ\ te\ same).\ Nie\ mo¿na\ tutaj\ zwolniæ\ pamiêci\ na\ koniec,\ gdy¿\ jest\ ona\ u¿ywana\ po\ stronie\ serwera(je¶li\ zwolnimy\ to\ stracimy\ warto¶ci\ elementów\ macierzy).\n\nvoid\nprogmacierze_1(char\ *host)\n\{\n\tCLIENT\ *clnt\;\n\tMac\ \ *result_1\;\n\tDwieMac\ \ dodaj_1_arg\;\n\n\t\n\tprintf(\"Rows:\ \\n\")\;\n\tscanf(\"%i\",\ &dodaj_1_arg.M1.IleW)\;\n\tdodaj_1_arg.M2.IleW\ =\ dodaj_1_arg.M1.IleW\;\n\n\tprintf(\"Columns:\ \\n\")\;\n\tscanf(\"%i\",\ &dodaj_1_arg.M1.IleK)\;\n\tdodaj_1_arg.M2.IleK\ =\ dodaj_1_arg.M1.IleK\;\n\t\n\tdodaj_1_arg.M1.Elem.Elem_len\ =\ dodaj_1_arg.M1.IleW\ *\ dodaj_1_arg.M1.IleK\;\n\tdodaj_1_arg.M1.Elem.Elem_val\ =\ calloc(dodaj_1_arg.M1.Elem.Elem_len,\ sizeof(float))\;\n\n\tint\ i\ =\ 0\;\n\tfor\ (i\ =\ 0\;\ i\ <\ dodaj_1_arg.M1.Elem.Elem_len\;\ i++)\ \{\n\t\tprintf(\"Enter\ the\ value(first\ matrix):\ %i\\n\",\ i)\;\n\t\tfloat\ x\ =\ 0\;\n\t\tscanf(\"%f\",\ &x)\;\n\t\tdodaj_1_arg.M1.Elem.Elem_val\[i\]\ =\ x\;\n\t\}\n\n\t\n\tdodaj_1_arg.M2.Elem.Elem_len\ =\ dodaj_1_arg.M2.IleW\ *\ dodaj_1_arg.M2.IleK\;\n\tdodaj_1_arg.M2.Elem.Elem_val\ =\ calloc(dodaj_1_arg.M2.Elem.Elem_len,\ sizeof(float))\;\n\n\ti\ =\ 0\;\n\tfor\ (i\ =\ 0\;\ i\ <\ dodaj_1_arg.M2.Elem.Elem_len\;\ i++)\ \{\n\t\tprintf(\"Enter\ the\ value(second\ matrix):\ %i\\n\",\ i)\;\n\t\tfloat\ x\ =\ 0\;\n\t\tscanf(\"%f\",\ &x)\;\n\t\tdodaj_1_arg.M2.Elem.Elem_val\[i\]\ =\ x\;\n\t\}\n//\tfree(dodaj_1_arg.M1.Elem.Elem_val)\;\n//\tfree(dodaj_1_arg.M2.Elem.Elem_val)\;\n\nWiêksze\ zmiany\ natomiast\ zosta³y\ wprowadzone\ w\ pliku\ matrix_server.c(wzglêdem\ poprzedniego\ zadania),\ gdy¿\ tutaj\ na\ pocz±tku\ przypisujemy\ warto¶ci\ wierszy\ oraz\ kolumn\ do\ finalnych\ zmiennych,\ nastêpnie\ do\ finalnych(czyli\ do\ wyniku)\ zmiennych\ przypisujemy\ jak\ wcze¶niej\ d³ugo¶æ\ oraz\ tworzymy\ zmienn±\ do\ warto¶ci(zalokowan±).\ Nastêpnie\ w\ pêtli\ do\ warto¶ci(zmienna\ result.Elem.Elem_val\[i\])\ przypisujemy\ sumy\ elementów\ z\ pierwszej\ oraz\ drugiej\ macierzy.\ W\ przedostatnim\ kroku\ wypisujemy\ je\ po\ stronie\ serwera\ i\ na\ koniec\ zwalniamy\ pamiêæ\ warto¶ci.\n\nMac\ *\ndodaj_1_svc(DwieMac\ *argp,\ struct\ svc_req\ *rqstp)\{\n\tstatic\ Mac\ \ result\;\n\tresult.IleW\ =\ argp->M1.IleW\;\n\tresult.IleK\ =\ argp->M1.IleK\;\n\n\tresult.Elem.Elem_len\ =\ result.IleW\ *\ result.IleK\;\n\tresult.Elem.Elem_val\ =\ calloc(result.Elem.Elem_len,\ sizeof(float))\;\n\n\t\n\tint\ i\ =\ 0\;\n\tfor\ (i\ =\ 0\;\ i\ <\ result.Elem.Elem_len\;\ i++)\ \{\n\t\tresult.Elem.Elem_val\[i\]\ =\ argp->M1.Elem.Elem_val\[i\]\ +\ argp->M2.Elem.Elem_val\[i\]\;\n\t\}\n\n\ti\ =\ 0\;\n\tfor\ (i\ =\ 0\;\ i\ <\ result.Elem.Elem_len\;\ i++)\ \{\n\t\tprintf(\"Element\ \[%i\]\ has\ value\ =\ %f\\n\",\ i,\ result.Elem.Elem_val\[i\])\;\n\t\}\n\tfree(result.Elem.Elem_val)\;\n\treturn\ &result\;\n\}\n\nWydruk:\n\nSerwer:\n\ns396337@lts:~/Desktop/TAS\ sprawozdania/Temat\ A/Zadanie\ 4\$\ ./matrix_server\nElement\ \[0\]\ has\ value\ =\ 2.000000\nElement\ \[1\]\ has\ value\ =\ 4.000000\nElement\ \[2\]\ has\ value\ =\ 6.000000\nElement\ \[3\]\ has\ value\ =\ 8.000000\n\nKlient:\ns396337@lts:~/Desktop/TAS\ sprawozdania/Temat\ A/Zadanie\ 4\$\ ./matrix_client\ 127.0.0.1\nRows:\ \n2\nColumns:\ \n2\nEnter\ the\ value(first\ matrix):\ 0\n1\nEnter\ the\ value(first\ matrix):\ 1\n2\nEnter\ the\ value(first\ matrix):\ 2\n3\nEnter\ the\ value(first\ matrix):\ 3\n4\nEnter\ the\ value(second\ matrix):\ 0\n1\nEnter\ the\ value(second\ matrix):\ 1\n2\nEnter\ the\ value(second\ matrix):\ 2\n3\nEnter\ the\ value(second\ matrix):\ 3\n4\n
